# EIP-2771 Integration Documentation

## Overview

This document describes the complete integration of EIP-2771 (Trusted Forwarder) into the Assetrix Diamond Contract to enable gasless transactions. The integration allows the backend to pay gas fees on behalf of users, providing a seamless user experience.

## Architecture

### Components

1. **EIP2771Context**: Base contract providing `_msgSender()` function
2. **TrustedForwarder**: Contract that relays transactions and pays gas
3. **TransactionEncoder**: Utility for encoding function calls with sender address
4. **Updated Facets**: All facets now use `_msgSender()` instead of `msg.sender`

### Flow

1. User signs a transaction (off-chain)
2. Backend receives the signed transaction
3. Backend calls `TrustedForwarder.forward()` with encoded data
4. `TrustedForwarder` pays gas and forwards to Diamond contract
5. Diamond contract extracts real sender using `_msgSender()`

## Contract Modifications

### 1. AssetrixStorage.sol
```solidity
struct Layout {
    // ... existing fields ...
    address trustedForwarder; // EIP-2771 trusted forwarder address
}
```

### 2. EIP2771Context.sol (New)
```solidity
contract EIP2771Context {
    function _msgSender() internal view returns (address) {
        // Extract real sender from trusted forwarder or return msg.sender
    }
}
```

### 3. TrustedForwarder.sol (New)
```solidity
contract TrustedForwarder {
    function forward(bytes calldata _data) external returns (bool, bytes memory) {
        // Forward transaction to Diamond contract
    }
}
```

### 4. Updated Facets

All facets now inherit from `EIP2771Context` and use `_msgSender()` in:
- Function bodies
- Custom modifiers (`onlyOwner`, `onlyDeveloperOrOwner`, `whenNotPaused`, `nonReentrant`, `onlyAuthorized`)

#### Functions Updated
- `AdminFacet`: All admin functions
- `PropertyFacet`: `createProperty`, `updateProperty`, `deactivateProperty`
- `InvestmentFacet`: `purchaseTokens`, `earlyExit`
- `FiatPaymentFacet`: `distributeTokensFromFiat`
- `MilestoneFacet`: `requestMilestoneFunds`, `markMilestoneCompleted`
- `TransactionFacet`: All transaction recording functions

#### Modifiers Updated
- `onlyOwner`: Now uses `_msgSender() == s.owner`
- `onlyDeveloperOrOwner`: Now uses `_msgSender() == s.properties[_propertyId].developerAddress || _msgSender() == s.owner`
- `whenNotPaused`: No change needed (only checks contract state)
- `nonReentrant`: No change needed (only checks contract state)
- `onlyAuthorized`: Now uses `_msgSender() == s.owner || _msgSender() == address(this)`

## Setup Instructions

### 1. Deploy Contracts
```bash
# Deploy Diamond contract first
npx hardhat deploy --contract Diamond

# Deploy TrustedForwarder
npx hardhat deploy --contract TrustedForwarder --args "[DIAMOND_ADDRESS]"

# Deploy TransactionEncoder (optional, for convenience)
npx hardhat deploy --contract TransactionEncoder
```

### 2. Configure Trusted Forwarder
```solidity
// Set trusted forwarder in Diamond contract
AdminFacet(diamond).setTrustedForwarder(trustedForwarderAddress);

// Authorize backend as relayer
TrustedForwarder(trustedForwarderAddress).authorizeRelayer(backendAddress);
```

### 3. Backend Configuration
```javascript
// Backend needs to:
// 1. Hold sufficient ETH for gas fees
// 2. Monitor for user transaction requests
// 3. Call TrustedForwarder.forward() with encoded data
```

## Frontend Integration

### 1. Transaction Encoding
```javascript
import { TransactionEncoder } from './contracts/TransactionEncoder';

// Encode purchase tokens transaction
const encodedData = TransactionEncoder.encodePurchaseTokens(
    userAddress,
    propertyId,
    tokenAmount
);
```

### 2. Send to Backend
```javascript
// Send encoded transaction to backend
const response = await fetch('/api/relay-transaction', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
        encodedData: encodedData,
        userAddress: userAddress,
        signature: userSignature
    })
});
```

### 3. Monitor Transaction
```javascript
// Monitor transaction status
const receipt = await response.json();
const txHash = receipt.transactionHash;

// Wait for confirmation
await web3.eth.waitForTransactionReceipt(txHash);
```

## Backend Integration

### 1. Transaction Relay Service
```javascript
class TransactionRelayService {
    async relayTransaction(encodedData, userAddress, signature) {
        // Verify user signature
        const isValid = this.verifySignature(encodedData, signature, userAddress);
        if (!isValid) throw new Error('Invalid signature');

        // Call TrustedForwarder
        const trustedForwarder = new web3.eth.Contract(TRUSTED_FORWARDER_ABI, TRUSTED_FORWARDER_ADDRESS);
        
        const result = await trustedForwarder.methods
            .forward(encodedData)
            .send({ from: backendAddress, gas: 500000 });

        return result;
    }
}
```

### 2. Gas Management
```javascript
// Monitor gas balance
async function checkGasBalance() {
    const balance = await web3.eth.getBalance(backendAddress);
    if (balance < MIN_GAS_BALANCE) {
        // Refill gas balance
        await refillGasBalance();
    }
}
```

## Security Considerations

### 1. Signature Verification
- Always verify user signatures before relaying
- Use EIP-712 for structured data signing
- Check signature nonces to prevent replay attacks

### 2. Authorization
- Only authorized relayers can call `TrustedForwarder.forward()`
- Backend must be explicitly authorized as a relayer
- Regular security audits of relayer authorization

### 3. Gas Limits
- Set appropriate gas limits for relayed transactions
- Monitor gas costs to prevent abuse
- Implement rate limiting if necessary

## Gas Cost Management

### 1. Gas Estimation
```javascript
// Estimate gas for relayed transaction
const gasEstimate = await trustedForwarder.methods
    .forward(encodedData)
    .estimateGas({ from: backendAddress });
```

### 2. Gas Optimization
- Batch multiple transactions when possible
- Use efficient encoding methods
- Monitor and optimize gas usage patterns

### 3. Cost Recovery
- Implement fee structures to recover gas costs
- Consider subscription models for frequent users
- Monitor and adjust pricing based on gas costs

## Monitoring and Testing

### 1. Event Monitoring
```javascript
// Monitor relay events
trustedForwarder.events.TransactionRelayed()
    .on('data', (event) => {
        console.log('Transaction relayed:', event.returnValues);
    });
```

### 2. Testing
```javascript
// Test gasless transaction flow
describe('EIP-2771 Integration', () => {
    it('should relay transaction successfully', async () => {
        // Test complete flow
    });
});
```

## Migration Guide

### From Direct Transactions
1. Update frontend to use transaction encoding
2. Implement backend relay service
3. Update gas fee handling
4. Test thoroughly before production

### Backward Compatibility
- Direct transactions still work (fallback to `msg.sender`)
- Gradual migration possible
- No breaking changes to existing functionality

## Troubleshooting

### Common Issues
1. **Invalid Sender**: Check transaction encoding
2. **Unauthorized Relayer**: Verify backend authorization
3. **Gas Limit Exceeded**: Adjust gas limits or optimize transactions
4. **Signature Verification Failed**: Check signature format and nonce

### Debug Tools
- Use `TransactionEncoder.getSender()` to verify sender extraction
- Monitor `TransactionRelayed` events for debugging
- Check trusted forwarder authorization status

## Conclusion

The EIP-2771 integration provides a complete gasless transaction solution for the Assetrix platform. All functions that require gas fees are now compatible with the trusted forwarder pattern, enabling seamless user experiences while maintaining security and functionality.
